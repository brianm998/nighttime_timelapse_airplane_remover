#!/usr/bin/perl

use strict;

# this script reads the outlier csv and text files and outputs ShoultPaint.swift

my $airplane_dir = "/Users/brian/git/nighttime_timelapse_airplane_eraser/outlier_data/airplanes";
my $non_airplane_dir = "/Users/brian/git/nighttime_timelapse_airplane_eraser/outlier_data/non_airplanes";

my $airplane_scores = process_csv_dir($airplane_dir);
my $non_airplane_scores = process_csv_dir($non_airplane_dir);

my ($airplane_value,     $airplane_center_line_count_position,
    $airplane_count,     $airplane_average_group_size,
    $airplane_average_fill_amount) = 
my ($non_airplane_value, $non_airplane_center_line_count_position,
    $non_airplane_count, $non_airplane_average_group_size,
    $non_airplane_average_fill_amount) = 

print ("keysOverLines: airplane $airplane_scores->{avg_keys_over_lines} non airplane $non_airplane_scores->{avg_keys_over_lines}\n");
print ("midIndex:      airplane $airplane_scores->{avg_center_line_count_position} non airplane $non_airplane_scores->{avg_center_line_count_position}\n");

open my $output, ">Sources/ntar/ShouldPaintConstants.swift";

print $output <<END
import Foundation

// do not edit this file by hand, it was generated by $0
// from $airplane_scores->{size} airplane outlier group records
// and $non_airplane_scores->{size} airplane outlier group records

// OAS == Outlier Analysis Score

// keys over lines is the number of unique line counts over the number of lines
// in the hough transform.  Lines tend towards fewer unique line counts.
// There cannot be more keys than lines so this number is betwen 0 and 1
let OAS_AIRPLANE_KEYS_OVER_LINES_AVG = $airplane_scores->{avg_keys_over_lines}
let OAS_NON_AIRPLANE_KEYS_OVER_LINES_AVG = $non_airplane_scores->{avg_keys_over_lines}

// the mid value is the index of the line in the sorted list that has the
// same value as the average of the highest line count and lowest line count
// the closer this is to the start, the more likely this is a line.
// each index is divided by the total number of lines so this number is between 0 and 1
let OAS_AIRPLANE_CENTER_LINE_COUNT_POSITION_AVG = $airplane_scores->{avg_center_line_count_position}
let OAS_NON_AIRPLANE_CENTER_LINE_COUNT_POSITION_AVG = $non_airplane_scores->{avg_center_line_count_position}

// the average size for each group type.  Larger is more likely to be an airplane streak
// value in in pixels
let OAS_AIRPLANE_GROUP_SIZE_AVG = $airplane_scores->{avg_group_size}
let OAS_NON_AIRPLANE_GROUP_SIZE_AVG = $non_airplane_scores->{avg_group_size}

// Average fill amount for each group type.  The fill amount is the amount
// of the outlier group's bounding box which is filled by the outlier.
// A fully filled in box is a retangle.  Values between 0 and 1.
let OAS_AIRPLANE_FILL_AMOUNT_AVG = $airplane_scores->{avg_fill_amount}
let OAS_NON_AIRPLANE_FILL_AMOUNT_AVG = $non_airplane_scores->{avg_fill_amount}

// the average aspect ratio for each group type.  average group width/height.
let OAS_AIRPLANE_ASPECT_RATIO_AVG = $airplane_scores->{avg_aspect_ratio}
let OAS_NON_AIRPLANE_ASPECT_RATIO_AVG = $non_airplane_scores->{avg_aspect_ratio}

END
;

close $output;

########
# subs #
########

my $histogram_size = 10;	# XXX expose this

sub process_csv_dir($) {
  my ($dirname) = @_;

  opendir my $dir, $dirname or die "cannot open source dir: $!\n";

  my $total_csv_count = 0;
  my $center_line_count_position_count = 0;

  my $total_keys_over_lines = 0;
  my $total_center_line_count_position = 0;
  my $total_group_size = 0;
  my $total_fill_amount = 0;
  my $total_aspect_ratio = 0;


  foreach my $filename (readdir $dir) {
    if ($filename =~ /^(.*)[.]csv$/) {
      my $first_part = $1;

      open my $txt_file, "<$dirname/$first_part.txt";
      my $group_size = 0;
      my $group_width = undef;
      my $group_height = 0;
      while(<$txt_file>) {
	$group_width = length $_ unless defined $group_width;
	$group_height++;
	my $count = $_ =~ tr/[*]//;
	$group_size += $count;
      }
      $total_aspect_ratio += $group_width/$group_height;
      $total_group_size += $group_size;
      $total_fill_amount += $group_size / ($group_width * $group_height);
      close $txt_file;

      open my $fh, "<$dirname/$filename";

      my $line_count_map = {};
      my $line_count = 0;
      my $first_count = undef;
      my $last_count = undef;
      my @lines = ();

      while (<$fh>) {
	if (/^([^,]+),([^,]+),([^,]+)$/) {
	  my ($theta, $rho, $count) = ($1, $2, $3);
	  chomp $count;
	  $first_count = $count unless defined $first_count;
	  $line_count++;
	  $line_count_map->{$count}++;
	  push @lines, $count;
	  $last_count = $count;
	}
      }
      close $fh;

      if ($line_count > 0) {
	# find the average of first and last count, and then find the index of that
	# value in @lines.  Use the value of this index and the length of @lines as an indicator

	my $mid_count = ($first_count - $last_count) / 2;

	my $mid_index = undef;
	my $center_line_count_position = undef;

	for (my $i = 0 ; $i < scalar(@lines) ; $i++) {
	  if ($lines[$i] <= $mid_count) {
	    $mid_index = $i;
	    $center_line_count_position = $mid_index / scalar(@lines);
	    $total_center_line_count_position += $center_line_count_position;
	    $center_line_count_position_count++;
	    last;
	  }
	}

	# compare the number of keys with the number of lines
	my $key_count = scalar(keys %$line_count_map);
	$total_csv_count++;
	my $keys_over_lines = $key_count / $line_count;

	$total_keys_over_lines += $keys_over_lines;

      }

#      print "$filename has $line_count lines and $key_count keys $first_count first count $keys_over_lines percentage\n";
    }
  }
  if ($total_csv_count > 0) {
    #print("dividing $total_keys_over_lines by $total_csv_count\n");
    $total_keys_over_lines /= $total_csv_count;
    $total_group_size /= $total_csv_count;
    $total_fill_amount /= $total_csv_count;
    $total_aspect_ratio /= $total_csv_count;
  }
  if ($center_line_count_position_count > 0) {
    $total_center_line_count_position /= $center_line_count_position_count;
  }
  closedir $dir;

  #print "we found $total_center_line_count_position average mid value\n";

  return {
	  avg_keys_over_lines => $total_keys_over_lines,
	  avg_center_line_count_position => $total_center_line_count_position,
	  avg_group_size => $total_group_size,
	  avg_fill_amount => $total_fill_amount,
	  avg_aspect_ratio => $total_aspect_ratio,
	  size => $total_csv_count,
	 };
}
