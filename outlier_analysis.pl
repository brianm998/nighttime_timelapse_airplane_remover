#!/usr/bin/perl

use strict;

# this script reads the outlier csv and text files and outputs ShoultPaint.swift

my $airplane_dir = "/Users/brian/git/nighttime_timelapse_airplane_eraser/outlier_data/airplanes";
my $non_airplane_dir = "/Users/brian/git/nighttime_timelapse_airplane_eraser/outlier_data/non_airplanes";

my $airplane_scores = process_csv_dir($airplane_dir);
my $non_airplane_scores = process_csv_dir($non_airplane_dir);

my ($airplane_value,     $airplane_mid_value,
    $airplane_count,     $airplane_average_group_size,
    $airplane_average_fill_amount) = 
my ($non_airplane_value, $non_airplane_mid_value,
    $non_airplane_count, $non_airplane_average_group_size,
    $non_airplane_average_fill_amount) = 

print ("keysOverLines: airplane $airplane_scores->{avg_keys_over_lines} non airplane $non_airplane_scores->{avg_keys_over_lines}\n");
print ("midIndex:      airplane $airplane_scores->{avg_mid_value} non airplane $non_airplane_scores->{avg_mid_value}\n");

open my $output, ">Sources/ntar/ShouldPaintConstants.swift";

print $output <<END
import Foundation

// do not edit this file by hand, it was generated by $0
// from $airplane_scores->{size} airplane outlier group records
// and $non_airplane_scores->{size} airplane outlier group records

// OAS == Outlier Analysis Score

// keys over lines is the number of unique line counts over the number of lines
// in the hough transform.  Lines tend towards fewer unique line counts.
// There cannot be more keys than lines so this number is betwen 0 and 1
let OAS_AIRPLANE_KEYS_OVER_LINES_AVG = $airplane_scores->{avg_keys_over_lines}
let OAS_NON_AIRPLANE_KEYS_OVER_LINES_AVG = $non_airplane_scores->{avg_keys_over_lines}

// the mid value is the index of the line in the sorted list that has the
// same value as the average of the highest line count and lowest line count
// the closer this is to the start, the more likely this is a line.
// each index is divided by the total number of lines so this number is between 0 and 1
let OAS_AIRPLANE_MID_VALUE_AVG = $airplane_scores->{avg_mid_value}
let OAS_NON_AIRPLANE_MID_VALUE_AVG = $non_airplane_scores->{avg_mid_value}

// the average size for each group type.  Larger is more likely to be an airplane streak
// value in in pixels
let OAS_AIRPLANE_GROUP_SIZE_AVG = $airplane_scores->{avg_group_size}
let OAS_NON_AIRPLANE_GROUP_SIZE_AVG = $non_airplane_scores->{avg_group_size}

// Average fill amount for each group type.  The fill amount is the amount
// of the outlier group's bounding box which is filled by the outlier.
// A fully filled in box is a retangle.  Values between 0 and 1.
let OAS_AIRPLANE_FILL_AMOUNT_AVG = $airplane_scores->{avg_fill_amount}
let OAS_NON_AIRPLANE_FILL_AMOUNT_AVG = $non_airplane_scores->{avg_fill_amount}

END
;

close $output;

########
# subs #
########

sub process_csv_dir($) {
  my ($dirname) = @_;

  opendir my $dir, $dirname or die "cannot open source dir: $!\n";

  my $total_keys_over_lines;
  my $total_csv_count = 0;
  my $airplane_count = 0;
  my $old_airplane_count = 0;

  my $average_mid_value = 0;
  my $mid_value_count = 0;

  my $total_group_size = 0;
  my $total_fill_amount = 0;

  foreach my $filename (readdir $dir) {
    if ($filename =~ /^(.*)[.]csv$/) {
      my $first_part = $1;

      open my $txt_file, "<$dirname/$first_part.txt";
      my $group_size = 0;
      # XXX aso get width, height, aspect ratio and fill amount
      my $group_width = undef;
      my $group_height = 0;
      while(<$txt_file>) {
	$group_width = length $_ unless defined $group_width;
	$group_height++;
	my $count = $_ =~ tr/[*]//;
	$group_size += $count;
      }
      $total_group_size += $group_size;
      $total_fill_amount += $group_size / ($group_width * $group_height);
      close $txt_file;

      open my $fh, "<$dirname/$filename";

      my $line_count_map = {};
      my $line_count = 0;
      my $first_count = undef;
      my $last_count = undef;
      my @lines = ();

      while (<$fh>) {
	if (/^([^,]+),([^,]+),([^,]+)$/) {
	  my ($theta, $rho, $count) = ($1, $2, $3);
	  chomp $count;
	  $first_count = $count unless defined $first_count;
	  $line_count++;
	  $line_count_map->{$count}++;
	  push @lines, $count;
	  $last_count = $count;
	}
      }
      close $fh;

      if ($line_count > 0) {
	# find the average of first and last count, and then find the index of that
	# value in @lines.  Use the value of this index and the length of @lines as an indicator

	my $mid_count = ($first_count - $last_count) / 2;

	my $mid_index = undef;
	my $mid_value = undef;

	for (my $i = 0 ; $i < scalar(@lines) ; $i++) {
	  if ($lines[$i] <= $mid_count) {
	    $mid_index = $i;
	    $mid_value = $mid_index / scalar(@lines);
	    $average_mid_value += $mid_value;
	    $mid_value_count++;
	    last;
	  }
	}

	# compare the number of keys with the number of lines
	my $key_count = scalar(keys %$line_count_map);
	$total_csv_count++;
	my $keys_over_lines = $key_count / $line_count;

	$total_keys_over_lines += $keys_over_lines;

	my $median = (0.019093043175072 + 0.511631866903208) / 2;

	my $median2 = (0.0459842606145003 + 0.125522340303945) / 2;

	if (($mid_value < $median && $keys_over_lines < $median2)) {
	  $airplane_count++;
	}
	if($lines[9]/$lines[0] < 0.5) {
	  $old_airplane_count++;
	}
      }

#      print "$filename has $line_count lines and $key_count keys $first_count first count $keys_over_lines percentage\n";
    }
  }
  if ($total_csv_count > 0) {
    #print("dividing $total_keys_over_lines by $total_csv_count\n");
    $total_keys_over_lines /= $total_csv_count;
    $total_group_size /= $total_csv_count;
    $total_fill_amount /= $total_csv_count;
  }
  if ($mid_value_count > 0) {
    $average_mid_value /= $mid_value_count;
  }
  closedir $dir;

  my $percentage_airplanes = $airplane_count/$total_csv_count*100;
  my $percentage_old_airplanes = $old_airplane_count/$total_csv_count*100;
  
  print "we found $airplane_count airlines in data of size $total_csv_count $percentage_airplanes% correct ($percentage_old_airplanes% old correct)\n";

  #print "we found $average_mid_value average mid value\n";

  return {
	  avg_keys_over_lines => $total_keys_over_lines,
	  avg_mid_value => $average_mid_value,
	  avg_group_size => $total_group_size,
	  avg_fill_amount => $total_fill_amount,
	  size => $total_csv_count,
	 };
}
